---
title: 你不知道的Javascript笔记
date: 2022-02-10 17:59:43
permalink: /pages/7ce210/
categories:
  - 杂
tags:
  - 
---

## 作用域

作用域是一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。

> 1. 引擎：从头到尾负责整个 JavaScript 程序的**编译及执行过程**
> 2. 编译器：负责**语法分析**及**代码生成**等（目的是为引擎生成运行时所需的代码）
> 3. 作用域：负责**收集**并**维护**由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前**执行的代码**对这些标识符的**访问权限**

### 引擎对变量的查询方式

- **LHS 查询**，目的是对变量进行赋值（试图找到容器本身）

- **RHS 查询**，目的是获取变量的值

### 作用域嵌套

一个块或函数嵌套在另一个块或函数中时，会产生作用域嵌套。

引擎执行当前代码时，遇到变量会发生 RHS 或 LHS，两种查询都会在当前执行作用域中开始，当前作用域没有找到所需标识符，就会上层作用域继续查找目标标识符，直到找到第一个匹配的目标标识符或到达全局作用域。

在多层嵌套的作用域中定义同名的标识符，会出现遮蔽效应（内部标识符遮蔽外部标识符）。

### 作用域查找异常

**LHS 查询异常**

- 非严格模式，自动隐式的创建一个全局变量
- 严格模式，引擎抛出 **ReferenceError** 异常

**RHS 查询异常**

引擎会抛出 **ReferenceError** 异常。

*RHS 查询变量成功，后续对变量做了不合理操作（非 Function 类型进行函数调用，获取 undefined | null 的属性等），引擎会抛出 **TypeError***

### 词法作用域

作用域有两种主要的工作模型，**词法作用域**是最为普遍的。（另外一种是*动态作用域*）

词法作用域的定义是在编译器的词法分析阶段。故词法作用域是由写代码时将变量和块作用域写在哪里来决定的

词法作用域查找只会查找一级标识符。

> 如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。

**欺骗词法作用域**

在运行时修改词法作用域（会导致性能下降）

1. `eval()`

      接受字符串作为参数，将其生成代码并运行。（修改了书写期词法作用域的环境）

      严格模式，eval()在运行时有自己的词法作用域。

      > **类似功能**
      > - setTimeout()、setInterval() 的第一个参数可以是字符串。（已过时）
      > - new Function() 最后一个参数可以接受字符串

2. `with(obj) {...}`

      width 将传入的对象的引用处理为一个**完全隔离的词法作用域**，在运行时创建了一个新的词法作用域，对象的属性会处理成定义在这个作用域的词法标识符。（ var 声明不会被限制在这个块作用域中 ）

      严格模式，with 被禁用

3. 性能

      引擎在编译阶段会进行数项性能优化，部分优化依赖于能够根据代码的词法进行静态分析，预先确定所有变量和函数的定义未知，才能在执行过程中快速找到标识符。
      欺骗词法作用域的副作用是，引擎无法在编译时对**作用域查找**进行优化，因为引擎只能谨慎的认为这样的优化是无效的，导致代码运行变慢。

### 作用域类型

####  全局作用域

#### 函数作用域

JavaScript 具有基于函数的作用域。

函数作用域内的全部变量都可以在整个函数以及嵌套的作用域范围内使用并复用（充分利用 JavaScript 变量值类型可以改变的*动态*特性， 本质是**变量提升**）

**隐藏内部实现**

软件设计中，应最小限度地暴露必要内容，将其他内容隐藏起来（最小(授权|暴露)原则）。

**规避冲突**

避免同名标识符之间的冲突

1. 全局命名空间：声明一个变量对象（命名空间），将要暴露给外界的功能定义为此对象的属性

2. 模块管理

**立即执行函数表达式**

IIFE（Immediately Invoked Function Expression），通过 `()` 包裹使函数声明变为函数表达式，如果是具名函数，函数名不会污染所在作用域。

**function**关键字的位置决定了函数是函数声明还是函数表达式

- 具名立即执行函数

      // 函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行
      (function foo() {...})()

      (function foo() {...}())

- 匿名立即执行函数

#### 块作用域

块作用域是对**最小授权原则**进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。

**with**

用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。

**try/catch**

catch 分句会创建一个块作用域，其中的声明仅在 catch 内部生效（块仅对 error 有意义）。

      try {
            undefined() // 执行一个非法操作来强制制造一个异常
      } catch (error) {
            var m = 111
            console.log( error ) // 能够正常执行！
      }
      console.log( m ) // 能正常打印 111
      console.log( error ) // Uncaught ReferenceError: error is not defined


**let**

let 关键字可以将变量绑定到所在作用域或所在 `{...}`。

let 将变量附加到已经存在的作用域上的行为是**隐式的**。

let 可以通过 `{...}` 显示的创建块，变量的附属关系相较于隐式更加清晰。

let 声明的变量不会在块作用域中进行提升

- 垃圾回收，将变量定义和变量使用写在一个代码块中，块作用域中代码执行完毕，可进行垃圾回收。

- let 循环，`for (let i = 0; i < 10; i++) {...}` 循环头部发 let 将 i 绑定到 for 循环的块中，循环的每个迭代会**重新绑定**

**const**

同 let 一样，会劫持所在 `{...}`形成块作用域。不同的是，其声明的变量是个常量，修改值的操作会引起错误。

